
  <!DOCTYPE html>
  <html>
    <head>
      <title>test.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="..\..\..\assets\source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="..\..\..\assets\source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="..\..\..\index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src\test\test.ts</td><td class="">100.00%</td><td class="">80%</td><td class="">29</td><td class="">29</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">// import &quot;reflect-metadata&quot;;

// @Reflect.metadata(&#x27;role&#x27;, &#x27;admin&#x27;)
// class Post {}

// const metadata = Reflect.getMetadata(&#x27;role&#x27;, Post);

// console.log(metadata);  // admin

// @Reflect.metadata(&#x27;name&#x27;, &#x27;A&#x27;)
// class A {}

// Object.getOwnPropertySymbols(A) // []

// interface Thing { /* nothing here */ }
// function doSomething(a: Thing) {
//   // mysterious implementation here
// }
// // Expected some or all of these to be errors
// doSomething(window);
// doSomething(42);
// doSomething(&#x27;huh?&#x27;);

// type SomeUrl = string;
// type FirstName = string;
// let x: SomeUrl = &quot;http://www.typescriptlang.org/&quot;;
// let y: FirstName = &quot;Bob&quot;;
// x = y; // Expected error

// type SomeUrl = string &amp; {&#x27;this is a url&#x27;: {}};
// type FirstName = string &amp; {&#x27;person name&#x27;: {}};

// // Add type assertions
// let x = &#x27;&#x27; as SomeUrl;
// let y = &#x27;bob&#x27; as FirstName;
// // x = y; // Error

// // OK
// let xs: string = x;
// let ys: string = y;
// xs = ys;
// console.log(xs)

// interface ScreenCoordinate {
//     a:any;
//   x: number;
//   y: number;
// }
// interface PrintCoordinate {
//     b:any
//   x: number;
//   y: number;
// }
// function sendToPrinter(pt: PrintCoordinate) {
//   // ...
// }
// function getCursorPos(): ScreenCoordinate {
//   // Not a real implementation
//   return { x: 0, y: 0 } as ScreenCoordinate;
// }
// // This should be an error
// sendToPrinter(getCursorPos());

// // Define FooTable and FooIndex
// type FooIndex = string;  // Proposed new kind of nominal declaration.
// interface FooTable {
//   [i: string]: { foo: number };
// }
// let s1: FooIndex;
// let t1: FooTable;

// // Define BarTable and BarIndex
// type BarIndex = string; // Proposed new kind of nominal declaration.
// interface BarTable {
//   [i: string]: { bar: string };
// }
// let s2: BarIndex;
// let t2: BarTable;

// // For assignment from base-types and basic structures: no type-overloading is needed.
// s1 = &#x27;foo1&#x27;;
// t1 = {};
// t1[s1] = { foo: 1 };

// s2 = &#x27;bar1&#x27;;
// t2 = { &#x27;bar1&#x27;: { bar: &#x27;barbar&#x27; }};

// console.log(s2 = s1); // Proposed to be type error.
// console.log(s2 == s1); // Proposed to be type error.
// console.log(s2 === s1); // Proposed to be type error.

// t1[s2].foo = 100; // Gives a runtime error. Proposed to be type error.
// t1[s1].foo = 100;

// function BadFooTest(t: FooTable) {
//   if (s2 in t) {  // Proposed to be type error.
//     console.log(&#x27;cool&#x27;);
//     console.log(t[s2].foo); // Proposed to be type error.
//   }
// }

// function GoodBarTest(t: BarTable) {
//   if (s2 in t) {
//     console.log(&#x27;cool&#x27;);
//     console.log(t[s2].bar);
//   }
// }

// BadFooTest(t1); // Gives runtime error;
// BadFooTest(t2); // No runtime error, Proposed to be type error.
// GoodBarTest(t1); // Gives runtime error; Proposed to be type error.
// GoodBarTest(t2);

// let x: any = true;
// let y = x as string; // Expected: runtime error (can&#x27;t convert boolean to string)

// let a: any = &#x27;hmm&#x27;;
// let b = a as HTMLElement; // expected b === null

// console.log(y)
// console.log(b)

// let myFunc: (number) =&gt; string = (n) =&gt; &#x27;The number in hex is &#x27; + n.toString(16);
// // Expected error because boolean is not number
// console.log(myFunc(true));

// interface Car{
//     name: string
// }
// interface Animal{
//     name: string
// }
// // let x: { [n: string]: Car; };
// // let y: { [n: string]: Animal; };
// // x = y; // Error

// let c: Car = {
//     name:&#x27;aaa&#x27;
// };
// // Error, or not?
// let x: { [n: string]: Car } = { &#x27;mine&#x27;: c };

// function createLog(message:string): number;
// function createLog(source:string, message:string): number
// function createLog(source:string, message?:string): number {
//   return 0;
// }

// let a = createLog(&quot;message&quot;); // OK
// let b = createLog(&quot;source&quot;, &quot;message&quot;);

// console.log(a)
// console.log(b)

// function compare(a: string, b: string): void;
// function compare(a: number, b: number): void;
// function compare(a: string|number, b: string|number): void {
//   // Just an implementation and not visible to callers
// }

// compare(1,2) // OK
// compare(&quot;s&quot;, &quot;l&quot;) // OK
// compare (1, &quot;l&quot;) // Error.

// class Base {
//     important: number;
//     properties: number;
// }
// class Alpha extends Base { }
// class Bravo extends Base { }

// const a = new Alpha()
// const b = new Bravo()
// console.log(a)
// console.log(b)

// a.important = 1

// console.log(a)
// console.log(b)

// class Alpha { x: number }
// class Bravo { x: number }
// class Charlie {
//   protected x: number
//   add(){
//     console.log(this.x)
//   }
// }
// class Delta {
//   protected x: number
//   add(){
//     console.log(this.x)
//   }
// }

// // tslint:disable-next-line: one-variable-per-declaration
// let a = new Alpha(), b = new Bravo(), c = new Charlie(), d = new Delta();

// a = b; // OK
// c = d; // Error

// class MyClass {
//   x = 10;
//   someCallback() {
//     console.log(this.x); // Prints &#x27;undefined&#x27;, not 10
//     this.someMethod(); // Throws error &quot;this.method is not a function&quot;
//   }
//   someMethod() {

//   }
// }

// let obj = new MyClass();
// // global.setTimeout(obj.someCallback, 10);
// global.setTimeout(obj.someCallback.bind(obj), 10);

// class MyClass {
//   x = 10;
//   someCallback() {
//     console.log(this.x); // Prints &#x27;undefined&#x27;, not 10
//     this.someMethod(); // Throws error &quot;this.method is not a function&quot;
//   }
//   time(){
//     global.setTimeout(this.someCallback.bind(this), 1000);
//   }
//   someMethod() {

//   }
// }

// let obj = new MyClass();
// obj.time()

// class Base {

//   myVar:string = &#x27;Base&#x27;;

//   constructor() {
//       console.log(this.myVar);
//   }

// }

// class Child extends Base {

//   myVar:string = &#x27;Child&#x27;;

// }

// let base:Base = new Base(); // &#x27;Base&#x27; - As expected
// let child:Child = new Child(); // &#x27;Base&#x27; - I would&#x27;ve expected this to be &#x27;Child&#x27;

// console.log(base.myVar); // &#x27;Base&#x27; - As expected
// console.log(child.myVar); // &#x27;Child&#x27; - As expected

// class Base {

//   myVar:string = &#x27;Base&#x27;;

//   constructor() {
//       this.setup();
//   }

//   protected setup() {
//       console.log(this.myVar);
//   }

// }

// class Child extends Base {

//   myVar:string = &#x27;Child&#x27;;

//   constructor() {
//       super();
//       this.setup();
//   }

// }

// // let base:Base = new Base(); // &#x27;Base&#x27;
// let child:Child = new Child(); // &#x27;Child&#x27; - Now as expected

// // console.log(base.myVar); // &#x27;Base&#x27;
// // console.log(child.myVar); // &#x27;Child&#x27;

// class FooError extends Error {
//   constructor(m: string) {
//       super(m);
//   }
//   sayHello() {
//       return &quot;hello &quot; + this.message;
//   }
// }

// class FooError extends Error {
//   constructor(m: string) {
//       super();

//       // Set the prototype explicitly.
//       Object.setPrototypeOf(this, FooError.prototype);
//   }

//   sayHello() {
//       return &quot;hello &quot; + this.message;
//   }
// }

// console.log(new FooError(&#x27;error&#x27;))

// interface Something&lt;T&gt; {
//   name: string;
// }
// let x: Something&lt;number&gt; = {
//   name: &#x27;1&#x27;
// };
// let y: Something&lt;string&gt; = {
//   name: &#x27;1&#x27;
// };
// // Expected error: Can&#x27;t convert Something&lt;number&gt; to Something&lt;string&gt;!
// x = y;

// interface Named&lt;T&gt; {
//   name: string;
// }
// class MyNamed&lt;T&gt; implements Named&lt;T&gt; {
//   name: &#x27;mine&#x27;;
// }
// function findByName&lt;T&gt;(x: Named&lt;T&gt;): T {
//   // TODO: Implement
//   return undefined;
// }

// let x: MyNamed&lt;string&gt;;
// let y = findByName(x); // expected y: string, got y: {}

// interface Named&lt;T&gt; {
//   name: string;
//   value: T; // &lt;-- added
// }
// class MyNamed&lt;T&gt; implements Named&lt;T&gt; {
//   name: &#x27;mine&#x27;;
//   value: T; // &lt;-- added
// }
// function findByName&lt;T&gt;(x: Named&lt;T&gt;): T {
//   // TODO: Implement
//   return T;
// }

// let x: MyNamed&lt;string&gt; = {
//   name:&#x27;mine&#x27;,
//   value: &#x27;aaa&#x27;
// };
// console.log(x)
// let y = findByName(x); // got y: string;

// function doSomething&lt;T&gt;(x: T) {
//   // Can&#x27;t find name T?
//   let xType = typeof T;
//   let y = new xType();
//   // Same here?
//   if(someVar instanceof typeof T) {

//   }
//   // How do I instantiate?
//   let z = new T();

// class MyClass {}

// function create&lt;T&gt;(ctor: new() =&gt; T ) {
//   return new ctor();
// }
// let c = create(MyClass); // c: MyClass

// function isReallyInstanceOf&lt;T&gt;(ctor: new(...args: any[]) =&gt; T , obj: T) {
//   return obj instanceof ctor;
// }

// enum Alpha { X, Y, Z }
// const enum Beta { X, Y, Z }
// declare enum Gamma { X, Y, Z, O }
// declare const enum Delta { X, Y, Z }

// console.log(Alpha)
// console.log(Beta.X)
// // console.log(Beta[&quot;0&quot;])
// let a = &#x27;x&#x27;
// console.log(Gamma[a]) // Gamma is not defined
// // console.log(Delta)

// ts3.9以下版本bug
// interface Lion {

//     roar(): void

// }

// interface Seal {

//     singKissFromARose(): void

// }

// async function visitZoo(lionExhibit: Promise&lt;Lion&gt;, sealExhibit: Promise&lt;Seal | undefined&gt;) {

//     let [lion, seal] = await Promise.all([lionExhibit, sealExhibit]);

//     lion.roar(); // uh oh

// // ~~~~

// // Object is possibly &#x27;undefined&#x27;.

// }

// interface A {

//     a: number; // notice this is &#x27;number&#x27;

// }

// interface B {

//     b: string;

// }

// interface C {

//     a?: boolean; // notice this is &#x27;boolean&#x27;
//     b: string;

// }

// declare let x: A &amp; B;
// declare let y: C;

// y = x;

// declare function smushObjects&lt;T, U&gt;(x: T, y: U): T &amp; U;

// interface Circle {

//     kind: &quot;circle&quot;;
//     radius: number;

// }

// interface Square {

//     kind: &quot;square&quot;;
//     sideLength: number;

// }

// declare let x: Circle;
// declare let y: Square;
// let z = smushObjects(x, y);

// console.log(z.kind);

// let a = [{name:&#x27;a&#x27;,age:1},{name:&#x27;b&#x27;,age:2}]
// a.map(item =&gt;{item.name})

// let x = () =&gt; {10}

// function foo&lt;T extends any&gt;(arg: T) {
//     arg.spfjgerijghoied(); // no error!
// }

// function f() {
//     console.log(&quot;f(): evaluated&quot;);
//     return (target:any, propertyKey: string, descriptor: PropertyDescriptor) =&gt; {
//         console.log(&quot;f(): called&quot;);
//     }
// }

// function g() {
//     console.log(&quot;g(): evaluated&quot;);
//     return (target:any, propertyKey: string, descriptor: PropertyDescriptor) =&gt; {
//         console.log(&quot;g(): called&quot;);
//     }
// }

// class C {
//     @f()
//     @g()
//     method() {}
// }

// const a = new C();
// a.method()

// @sealed
// class Greeter {
//     greeting: string;
//     constructor(message: string) {
//         this.greeting = message;
//     }
//     greet() {
//         return &quot;Hello, &quot; + this.greeting;
//     }
// }

// function sealed(constructor: new(...args:any[]) =&gt; {}) {
//     Object.seal(constructor);
//     Object.seal(constructor.prototype);
//     console.log(constructor)
//     console.log(constructor.prototype);
// }

// function classDecorator&lt;T extends new(...args:any[]) =&gt; {}&gt;(constructor:T) {
//     return class extends constructor {
//         newProperty = &quot;new property&quot;;
//         hello = 111;
//     }
// }

// // tslint:disable-next-line: max-classes-per-file
// @classDecorator
// class Greeter {
//     property = &quot;property&quot;;
//     hello: string;
//     constructor(m: string) {
//         this.hello = m;
//     }
// }

// console.log(new Greeter(&quot;world&quot;));

// class Greeter {
//     greeting: string;
//     constructor(message: string) {
//         this.greeting = message;
//     }
//     set(message: string){
//         this.greeting = message
//     }

//     @enumerable(false)
//     greet() {
//         return &quot;Hello, &quot; + this.greeting;
//     }
// }

// function enumerable(value: boolean) {
//     return  (target: any, propertyKey: string, descriptor: PropertyDescriptor) =&gt; {
//         descriptor.enumerable = value;
//         descriptor.configurable = false;
//         // descriptor.writable = false;
//         console.log(descriptor)
//     };
// }

// console.log(delete Greeter.prototype.greet) // false

// class Point {
//     // tslint:disable-next-line: variable-name
//     private _x: number;
//     // tslint:disable-next-line: variable-name
//     private _y: number;
//     constructor(x: number, y: number) {
//         this._x = x;
//         this._y = y;
//     }

//     @configurable(false)
//     get x() { return this._x; }

//     @configurable(false)
//     get y() { return this._y; }
// }

// function configurable(value: boolean) {
//     return (target: any, propertyKey: string, descriptor: PropertyDescriptor) =&gt; {
//         console.log(target)
//         console.log(propertyKey)
//         descriptor.configurable = value;
//     };
// }

// const p = new Point(1,2)

// console.log(p.x)
// p.x = &#x27;4&#x27;

// function configurable(value:boolean){
//     return (target: any,propertyKey:string,descriptor: PropertyDescriptor) =&gt; {
//         descriptor.configurable = value;
//     }
// }

// class Greeter {
//     @format(&quot;Hello, %s&quot;)
//     greeting: string;

//     constructor(message: string) {
//         this.greeting = message;
//     }
//     greet() {
//         let formatString = getFormat(this, &quot;greeting&quot;);
//         return formatString.replace(&quot;%s&quot;, this.greeting);
//     }
// }

// const formatMetadataKey = Symbol(&quot;format&quot;);

// function format(formatString: string) {
//     return Reflect.metadata(formatMetadataKey, formatString);
// }

// function getFormat(target: any, propertyKey: string) {
//     return Reflect.getMetadata(formatMetadataKey, target, propertyKey);
// }

// const g = new Greeter(&#x27;msg&#x27;)
// console.log(g)

// 交叉类型和继承，以及ReactNode和ReactElement
// interface A {
//   name: string;
//   age: number;
// }

// interface B {
//   sex: string;
//   weight: number;
//   age: string;
// }
// const C: A &amp; B = {
//   name: &quot;&quot;,
//   age: 1,
//   sex: &quot;&quot;,
//   weight: 2,
// };

// interface C {
//   name: string;
//   age: number;
// }

// interface D extends C {
//   sex: string;
//   weight: number;
//   age: string;
// }

// const E: D = {
//   name: &quot;&quot;,
//   age: &quot;&quot;,
//   sex: &quot;&quot;,
//   weight: 23,
// };

// interface node {
//   a: React.ReactElement;
//   b: React.ReactNode;
// }

// const aaa: node = {
//   a: {
//     type: &quot;&quot;,
//     props: {},
//     key: null,
//   },
//   b: &quot;&quot;,
// };

// this 连贯接口继承
// class BasicCalculator {
//   constructor(protected value: number = 0) {}
//   currentValue(): number {
//     return this.value;
//   }
//   add(operand: number): this {
//     this.value += operand;
//     return this;
//   }
//   multiply(operand: number): this {
//     this.value *= operand;
//     return this;
//   }
//   // ... other operations go here ...
// }

// let v1 = new BasicCalculator(2).multiply(5).add(1).currentValue();
// console.log(v1);

// class ScientificCalculator extends BasicCalculator {
//   constructor(value = 0) {
//     super(value);
//   }
//   sin():this {
//     this.value = Math.sin(this.value);
//     return this;
//   }
//   // ... other operations go here ...
// }

// let v2 = new ScientificCalculator(2).multiply(5).sin().add(1).currentValue();
// console.log(v2)

// function pluck&lt;T, K extends keyof T&gt;(o: T, names: K[]): T[K][] {
//   return names.map((n) =&gt; o[n]);
// }

// interface Person {
//   name: string;
//   age: number;
//   sex: string;
// }
// let person: Person = {
//   name: &quot;Jarid&quot;,
//   age: 35,
//   sex: &#x27;man&#x27;
// };
// let strings: string[] = pluck(person, [&quot;name&quot;,&quot;sex&quot;]); // [ &#x27;Jarid&#x27;, &#x27;man&#x27; ]

// console.log(strings)

// type petsGroup = &#x27;dog&#x27; | &#x27;cat&#x27; | &#x27;fish&#x27;;
// interface IPetInfo {
//     name:string,
//     age:number,
// }

// type IPets = Record&lt;petsGroup, IPetInfo&gt;;

// const animalsInfo:IPets = {
//     dog:{
//         name:&#x27;dogName&#x27;,
//         age:2
//     },
//     cat:{
//         name:&#x27;catName&#x27;,
//         age:3
//     },
//     fish:{
//         name:&#x27;fishName&#x27;,
//         age:5
//     }
// }

// returnType使用
// function fn(): string {
//     return &#x27;aaaa&#x27;
// }

// function f1(s: string) {
//     return { a: 1, b: s };
// }

// const returnType1:ReturnType&lt;typeof fn&gt; = 1
// const returnType2:ReturnType&lt;typeof f1&gt; = {
//     a:555,
//     b:&#x27;ssss&#x27;
// }

// type Unpacked&lt;T&gt; =
//     T extends Array&lt;infer U&gt; ? U :
//     T extends (...args: any[]) =&gt; infer U ? U :
//     T extends Promise&lt;infer U&gt; ? U :
//     T;

// type T0 = Unpacked&lt;string&gt;;  // string
// type T1 = Unpacked&lt;string[]&gt;;  // string
// type T2 = Unpacked&lt;() =&gt; string&gt;;  // string
// type T3 = Unpacked&lt;Promise&lt;string&gt;&gt;;  // string
// type T4 = Unpacked&lt;Array&lt;Promise&lt;string&gt;&gt;&gt;;  // Promise&lt;string&gt;
// type T5 = Unpacked&lt;Unpacked&lt;Array&lt;Promise&lt;string&gt;&gt;&gt;&gt;;  // string

// type Foo&lt;T&gt; = T extends { a: infer U, b: infer U } ? U : never;
// type T10 = Foo&lt;{ a: string, b: string }&gt;;  // string
// type T11 = Foo&lt;{ a: string, b: number }&gt;;  // string | number

// interface Point {
//   x: number;
//   y: number;
//   new (x: number, y: number): Point;
// }

// class Point2D implements Point {
//   readonly x: number;
//   readonly y: number;

//   constructor(x: number, y: number) {
//     this.x = x;
//     this.y = y;
//   }
// }

// const point: Point = new Point2D(1, 2);

// class ExampleOne {
//     hi() {
//         alert(&#x27;Hi&#x27;);
//     }
// }

// class Creator&lt;T&gt; {
//     constructor() {

//     }
//     getNew() {
//         return new T();
//     }
// }

// let creator = new Creator&lt;ExampleOne&gt;();

// let example = creator.getNew();
// example.hi();

// class ExampleOne {
//     hi() {
//         console.log(&#x27;Hi&#x27;);
//     }
// }

// // interface ParameterlessConstructor&lt;T&gt; {
// //     new(): T;
// // }
// type ParameterlessConstructor&lt;T&gt; = new() =&gt; T;

// class Creator&lt;T&gt; {
//     constructor(private ctor: ParameterlessConstructor&lt;T&gt;) {

//     }
//     getNew() {
//         return new this.ctor();
//     }
// }

// let creator = new Creator(ExampleOne);

// let example = creator.getNew();
// example.hi();

// type Strings = [string, string];
// type Numbers = [number, number];

// // [string, string, number, number]
// type StrStrNumNum = [...Strings, ...Numbers];

// interface A  {
//     x: string,
//     y: number
// }

// interface B {
//     x: number,
//     y: string
// }

// type c = A | B;
// type d = A &amp; B;

// // const sss: string | number = &#x27;&#x27;
// const x:c = {
//    x: 1,
//    y: &#x27;2&#x27;
// }

// const y:d = {
//     x: 1,
//     y: &#x27;&#x27;
//  }

//  interface M {
//      a: string;
//  }

//  interface N{
//      a: string;
//      b: number
//  }

//  type o = M | N;
//  type p = M &amp; N;

//  const r:o = {
//     a: &#x27;&#x27;,
//     b: 1
//  }

//  const s:p = {
//      a: &#x27;&#x27;,
//      b: 44
//  }

// const obj = {
//   name: &quot;yj&quot;,
//   getName() {
//     return this.name // 可以自动推导为{ name:string, getName():string}类型
//   },
// }
// obj.getName() // string类型

// const obj2 = {
//   name: &quot;yj&quot;,
//   getName: () =&gt; {
//     return this.name // check 报错，这里的this指向的是window
//   },
// }
// obj2.getName() // 运行时报错

// const obj = {
//   name: &quot;yj&quot;,
//   getName() {
//     return this.name
//   },
// }
// const fn1 = obj.getName
// fn1() // this指向的是window，运行时报错

// interface Obj {
//     name: string
//     // 限定getName调用时的this类型
//     getName(this: Obj): string
//   }
//   const obj: Obj = {
//     name: &quot;yj&quot;,
//     getName() {
//       return this.name
//     },
//   }
//   obj.getName() // check ok
//   const fn1 = obj.getName
//   fn1() // check error

//   function People(name: string) {
//     this.name = name // check error
//   }
//   People.prototype.getName = function() {
//     return this.name
//   }
//   const people = new People() // check error

// class Parent {
//   constructor() {
//       console.log()
//     this.setup();
//   }

//   setup = () =&gt; {
//     console.log(&quot;parent&quot;);
//   };
// }

// class Child extends Parent {
//   constructor() {
//     super();
//   }

//   setup = () =&gt; {
//     console.log(&quot;child&quot;);
//   };
// }

// const child = new Child();


// interface Point {
//   x: number;
//   y: number;
// }
// const point : Point = {
//   x:1,
//   y:2,
//   z:3 // 报错，多余的属性
// } 






// 多于属性检测
// interface Point {
//   x: number;
//   y: number;
// }
// const point : Point = {
//   x:1,
//   y:2,
//   z:3 // 报错，多余的属性
// } as Point



// interface Point {
//   x: number;
//   y: number;
// }
// const tmp = {
//   x:1,
//   y:2,
//   z:3 
// }
// const point:Point= tmp; // 不报错


// interface Name {
//   first: string;
//   last: string
// }
// type Pick1&lt;T, K&gt;{
//   [k in K]: T[k]
// }
// // type FirstLast = Pick1&lt;Name, &#x27;first&#x27;| &#x27;last&#x27;&gt;
// // type FirstMiddle = Pick1&lt;Name, &#x27;first&#x27; | &#x27;middle&#x27;&gt; // 应该报错但没报错

// // 添加泛型约束
// type Pick2&lt;T, K extends keyof T&gt; = {
//   [k in K]: T[K]
// }
// type FirstMiddle = Pick2&lt;Name, &#x27;first&#x27;| &#x27;middle&#x27;&gt; // 正确的报错了


// const pt =  { x:3,y:4}
// const id = {name: &#x27;point&#x27;}
// const namedpoint = {}
// Object.assign(namedpoint, pt, id)
// namedpoint.name // check error

// const pt = { x:3, y: 4}
// const id = { name: &#x27;point&#x27;}
// const namedpoint = {...pt, ...id}
// namedpoint.name // 正常


interface Point {
  _brand?: &#x27;point&#x27;,
  x: number,
  y: number
}
interface RadiusPoint{
  _brand?: &#x27;radius&#x27;,
  x: number // radius
  y: number // theta
}
function PointDistance(p:Point){
  return Math.sqrt(p.x**2 + p.y**2)
}

let p1: Point = {
    x:1,
    y:2
};
let p2: RadiusPoint= {
    x:1,
    y:2
};
PointDistance(p1);
PointDistance(p2); // 正常报错</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Mon, 10 Aug 2020 02:25:52 GMT</p>
    </body>
  </html>
  